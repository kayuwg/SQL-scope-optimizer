For each column in outermost group by, find the raw table they belong to - they are the center tables
    For each table (all-levels):
        Create a map from table name to stmt node
        From schema info and functional dependency propagation rules, mark unique columns (or pairs of columns)
    Trace each column recursively

For each hole:
    Create map id_to_branch, from id to a list of branches
    // a piece of data is labeled an id
    // different branches for the same id means different possibilities for the same data
    // to obtain data of this id, we can also try assembling a candidate branch's children

    Prepare initial branch
        Set penalty = 0, eqPool = [], oblList = [], agg, key, depth = 1, parent = null, children = [], leaf = false, free = false, id = 1
    Add initial branch to id_to_branch
    new_branches = [initial branch]
    While new_branches is not empty:
        next_branches = []
        For branch in new_branches:
            If branch has top-level set operation (i.e. UNION):
                For each set operand, assign new id and add to next_branch
                continue
            
            // Phase 1: Cut off irrelevant tables
            Find all top level tables for the current scope
            Identify center tables (denoted I) and center columns
            Partition side tables into clusters
                Connect two tables if there is a predicate or column that involve both tables
                Find connected components
            Find the cluster that are involved in the hole (or no such cluster, i.e. hole only involves I)
            Remove all other clusters
            Check if the hole is idempotent (and incur panelty if needed)

            If branch have a single top-level table:
                Change column to be from smaller scope
                Add to next_branch, id_to_branch[subbranch.id]
                continue

            If there is a remaining cluster and it is independent of I:
                Remove I
                branch.free = true
                Restart the whole algorithm on this cluster
            
            
            // Phase 2: Split branches to resolve crossing
            If there is a remaining cluster:
                outer = I, inners = cluster
            Else if hole involves two or more tables:
                outer = one table, inners = remaining
            // crossing := anything that involve outer and a table from inner
            Convert predicate into CNF
            Collect conditions 1. that are conjuncts of CNF that cross 2. of CASE WHENs that cross
            disjunctions = []
            Spawn a "raw subbranch" for each possibility of the combination of the conditions (product rule)
                For each raw branch, simplify expression with Z3 strategy
                subbranch.parent = branch
                subbranch.id = ++global_counter
                Add subbranch.id to branch.children
                Add the subbranch to disjunctions
            
            // Phase 3:
            For each raw subbranch in disjunctions:
                subbranches_key_pushed = []
                If GROUP BY key is unique and Property 6/7 is satisfied:
                    Push key in accordingly and add to subbranches_key_pushed
                Else if one-to-one left join and Property 8 is satisfied:
                    Push key in accordingly and add to subbranches_key_pushed
                Else:
                    Buy assumptions to satisfy Property 6/7 or 8, add penalty, push in key
                    For each possibility of buying assumptions, add to subbranch_key_pushed
                For each subbranch in subbranches_key_pushed:
                    Push in filter (and buy assumptions)
                    For each possibility of buying assumptions, add to next_branch and id_to_branch[subbranch.id]

            If the branch is intact during the whole process:
                branch.leaf = true


        new_branches = next_branches

For each hole, use BFS to find ways to build id 1 with smallest penalties first
Combine top results from each hole, we have top queries