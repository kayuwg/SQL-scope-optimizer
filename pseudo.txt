For each column in outermost group by, find the raw table they belong to - they are the center tables
    For each table (all-levels):
        Create a map from table name to stmt node
        From schema info and functional dependency propagation rules, mark unique columns (or pairs of columns)
    Trace each column recursively

For each hole:
    Create map id_to_branch, from id to a list of branches
    // a piece of data is labeled an id
    // different branches for the same id means different possibilities for the same data
    // to obtain data of this id, we can also try assembling a candidate branch's children

    Prepare initial branch
        Set penalty = 0, eqPool = [], oblList = [], agg, key, depth = 1, parent = null, children = [], leaf = false, free = false, id = 1
    Add initial branch to id_to_branch
    new_branches = [initial branch]
    While new_branches is not empty:
        next_branches = []
        For branch in new_branches:
            If branch have a single top-level table and the table is raw:
                branch.leaf = true
                break
            
            // Phase 1: Cut off irrelevant tables
            Find all top level tables for the current scope
            Identify center tables (denoted I) and center columns
            Partition side tables into clusters
                Connect two tables if there is a predicate or column that involve both tables
                Find connected components
            Find the cluster that are involved in the hole (or no such cluster, i.e. hole only involves I)
            Remove all other clusters
            Check if the hole is idempotent (and incur panelty if needed)

            If there is a remaining cluster and it is independent of I:
                Remove I
                branch.free = true
                Restart the whole algorithm on this cluster

            If there is a remaining cluster:
                // Phase 2: Split branches to resolve crossing
                Convert predicate into CNF
                Collect conditions 1. that are conjuncts of CNF that cross 2. of CASE WHENs that cross
                disjunctions = []
                Spawn a "raw subbranch" for each possibility of the combination of the conditions (product rule)
                    For each raw branch, simplify expression with Z3 strategy
                    subbranch.parent = branch
                    subbranch.id = ++global_counter
                    Add subbranch.id to branch.children
                    Add the subbranch to disjunctions
                
                // Phase 3.2:
                For each raw subbranch in disjunctions:
                    subbranches_key_pushed = []
                    If GROUP BY key is unique and Property 6/7 is satisfied:
                        Push key in accordingly and add to subbranches_key_pushed
                    Else if one-to-one left join and Property 8 is satisfied:
                        Push key in accordingly and add to subbranches_key_pushed
                    Else:
                        Buy assumptions to satisfy Property 6/7 or 8, add penalty, push in key
                        For each possibility of buying assumptions, add to subbranch_key_pushed
                    For each subbranch in subbranches_key_pushed:
                        Push in filter (and buy assumptions)
                        For each possibility of buying assumptions, add to next_branch and id_to_branch[subbranch.id]
            Else:
                // Phase 3.1:
                Change column to be from smaller scope
                Add to next_branch, id_to_branch[subbranch.id]


        new_branches = next_branches

For each hole, use BFS to find ways to build id 1 with smallest penalties first
Combine top results from each hole, we have top queries